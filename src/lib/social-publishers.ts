import { sbServer } from '@/lib/supabase/server';
import { OAuthTokenManager } from '@/lib/services/TokenEncryptionService';

export interface PublishResult {
  success: boolean;
  externalPostId?: string;
  error?: string;
  platformResponse?: any;
  metadata?: any;
}

export interface PublishData {
  content: string;
  mediaUrls: string[];
  scheduledAt?: string;
  metadata?: any;
}

export interface SocialAccount {
  id: string;
  provider: string;
  name: string;
  token_encrypted: string;
  provider_id: string;
  metadata?: any;
}

/**
 * Base class cho t·∫•t c·∫£ social media publishers
 */
export abstract class BaseSocialPublisher {
  protected account: SocialAccount;

  constructor(account: SocialAccount) {
    this.account = account;
  }

  abstract publish(data: PublishData): Promise<PublishResult>;
  
  protected abstract decryptToken(encryptedToken: string): string;
  
  protected logPublishAttempt(data: PublishData, result: PublishResult) {
    console.log(`[${this.account.provider.toUpperCase()}] Publishing to ${this.account.name}:`, {
      success: result.success,
      externalPostId: result.externalPostId,
      error: result.error
    });
  }

  /**
   * Perform fetch with timeout and basic retries for transient failures
   */
  protected async fetchWithRetry(
    url: string,
    init: { method?: string; headers?: Record<string, string>; body?: any; timeoutMs?: number } = {}
  ): Promise<Response> {
    const {
      timeoutMs = 15000,
      ...rest
    } = init;

    const maxAttempts = 3;
    let attempt = 0;
    let lastError: any;

    while (attempt < maxAttempts) {
      attempt++;
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { ...(rest as any), signal: controller.signal } as any);
        clearTimeout(timeout);

        // Retry on 429/5xx
        if (res.status === 429 || (res.status >= 500 && res.status < 600)) {
          const backoff = 500 * Math.pow(2, attempt - 1);
          await new Promise(r => setTimeout(r, backoff));
          continue;
        }
        return res;
      } catch (e) {
        clearTimeout(timeout);
        lastError = e;
        // Retry on abort/network
        if (attempt < maxAttempts) {
          const backoff = 500 * Math.pow(2, attempt - 1);
          await new Promise(r => setTimeout(r, backoff));
          continue;
        }
      }
    }
    throw lastError || new Error('Network error');
  }
}

/**
 * Facebook Publisher
 */
export class FacebookPublisher extends BaseSocialPublisher {
  protected decryptToken(encryptedToken: string): string {
    return OAuthTokenManager.decryptForUse(encryptedToken);
  }

  async publish(data: PublishData): Promise<PublishResult> {
    try {
      const accessToken = this.decryptToken(this.account.token_encrypted);
      const pageId = this.account.provider_id;

      console.log('üîµ Facebook Publisher - Starting publish process:', {
        pageId,
        hasMedia: data.mediaUrls && data.mediaUrls.length > 0,
        isScheduled: !!data.scheduledAt
      });

      // Handle media upload first if present
      let uploadedMediaIds: string[] = [];
      if (data.mediaUrls && data.mediaUrls.length > 0) {
        console.log('üì∏ Uploading media to Facebook...');
        // Limit concurrent uploads to 3
        const concurrency = 3;
        let index = 0;
        const results: string[] = [];
        const uploadNext = async () => {
          while (index < data.mediaUrls!.length) {
            const current = index++;
            const mediaUrl = data.mediaUrls![current];
            try {
              const mediaId = await this.uploadMediaToFacebook(mediaUrl, accessToken, pageId);
              if (mediaId) results.push(mediaId);
            } catch (err) {
              console.error('Media upload failed:', err);
            }
          }
        };
        await Promise.all(new Array(Math.min(concurrency, data.mediaUrls.length)).fill(0).map(() => uploadNext()));
        uploadedMediaIds = results;
      }

      // Prepare post data
      const postData: any = {
        message: data.content,
        access_token: accessToken
      };

      // Attach uploaded media
      if (uploadedMediaIds.length > 0) {
        if (uploadedMediaIds.length === 1) {
          // Single photo post
          postData.object_attachment = uploadedMediaIds[0];
        } else {
          // Multiple photos post
          postData.attached_media = uploadedMediaIds.map(id => ({ media_fbid: id }));
        }
      }

      // Handle scheduling
      if (data.scheduledAt) {
        const scheduleTime = Math.floor(new Date(data.scheduledAt).getTime() / 1000);
        const now = Math.floor(Date.now() / 1000);
        
        // Facebook requires scheduled time to be at least 10 minutes in the future
        if (scheduleTime > now + 600) {
          postData.scheduled_publish_time = scheduleTime;
          postData.published = false;
          console.log('‚è∞ Scheduling post for:', new Date(data.scheduledAt));
        } else {
          console.log('‚ö†Ô∏è Schedule time too close, publishing immediately');
        }
      }

      // Determine API endpoint
      const endpoint = uploadedMediaIds.length > 0 
        ? `https://graph.facebook.com/v18.0/${pageId}/photos`
        : `https://graph.facebook.com/v18.0/${pageId}/feed`;

      console.log('üöÄ Calling Facebook API:', endpoint);

      // Call Facebook Graph API
      const response = await this.fetchWithRetry(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(postData),
        timeoutMs: 15000
      });

      const result = await response.json();
      
      console.log('üì° Facebook API Response:', {
        status: response.status,
        success: response.ok,
        data: result
      });

      if (response.ok && result.id) {
        const publishResult: PublishResult = {
          success: true,
          externalPostId: result.id,
          platformResponse: result,
          metadata: {
            uploadedMedia: uploadedMediaIds,
            endpoint: endpoint,
            scheduled: !!postData.scheduled_publish_time
          }
        };
        this.logPublishAttempt(data, publishResult);
        return publishResult;
      } else {
        // Handle Facebook API errors
        const errorMessage = this.getFacebookErrorMessage(result);
        const publishResult: PublishResult = {
          success: false,
          error: errorMessage,
          platformResponse: result
        };
        this.logPublishAttempt(data, publishResult);
        return publishResult;
      }

    } catch (error: any) {
      console.error('üî¥ Facebook Publisher Error:', error);
      const publishResult: PublishResult = {
        success: false,
        error: `Facebook publish error: ${error.message}`
      };
      this.logPublishAttempt(data, publishResult);
      return publishResult;
    }
  }

  /**
   * Upload media to Facebook and return media ID
   */
  private async uploadMediaToFacebook(mediaUrl: string, accessToken: string, pageId: string): Promise<string | null> {
    try {
      console.log('üì§ Uploading media:', mediaUrl);

      // For external URLs, use url parameter
      const uploadData = {
        url: mediaUrl,
        access_token: accessToken,
        published: false // Unpublished photo for later use in post
      };

      const response = await this.fetchWithRetry(`https://graph.facebook.com/v18.0/${pageId}/photos`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(uploadData),
        timeoutMs: 20000
      });

      const result = await response.json();

      if (response.ok && result.id) {
        console.log('‚úÖ Media uploaded successfully:', result.id);
        return result.id;
      } else {
        console.error('‚ùå Media upload failed:', result);
        return null;
      }
    } catch (error) {
      console.error('‚ùå Media upload error:', error);
      return null;
    }
  }

  /**
   * Parse Facebook API error messages
   */
  private getFacebookErrorMessage(result: any): string {
    if (result.error) {
      const { message, code, error_user_title, error_user_msg } = result.error;
      
      // Common Facebook error codes
      switch (code) {
        case 190:
          return 'Token Facebook ƒë√£ h·∫øt h·∫°n. Vui l√≤ng k·∫øt n·ªëi l·∫°i t√†i kho·∫£n.';
        case 200:
          return 'Kh√¥ng c√≥ quy·ªÅn ƒëƒÉng b√†i l√™n trang n√†y. Vui l√≤ng ki·ªÉm tra quy·ªÅn admin.';
        case 368:
          return 'T·∫°m th·ªùi kh√¥ng th·ªÉ ƒëƒÉng b√†i. Trang Facebook c√≥ th·ªÉ b·ªã h·∫°n ch·∫ø.';
        case 506:
          return 'N·ªôi dung b√†i vi·∫øt vi ph·∫°m ch√≠nh s√°ch c·ªßa Facebook.';
        case 1500:
          return 'Kh√¥ng th·ªÉ ƒëƒÉng b√†i v√†o th·ªùi ƒëi·ªÉm n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.';
        default:
          return error_user_msg || message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ Facebook API.';
      }
    }
    
    return 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi ƒëƒÉng b√†i l√™n Facebook.';
  }
}

/**
 * Instagram Publisher
 */
export class InstagramPublisher extends BaseSocialPublisher {
  protected decryptToken(encryptedToken: string): string {
    return OAuthTokenManager.decryptForUse(encryptedToken);
  }

  async publish(data: PublishData): Promise<PublishResult> {
    try {
      const accessToken = this.decryptToken(this.account.token_encrypted);
      const accountId = this.account.provider_id;

      console.log('üì∏ Instagram Publisher - Starting publish process:', {
        accountId,
        mediaCount: data.mediaUrls?.length || 0,
        isScheduled: !!data.scheduledAt
      });

      // Instagram requires media for posts
      if (!data.mediaUrls || data.mediaUrls.length === 0) {
        return {
          success: false,
          error: 'Instagram posts require at least one image or video'
        };
      }

      // Handle single vs multiple media
      if (data.mediaUrls.length === 1) {
        return await this.publishSingleMedia(data, accessToken, accountId);
      } else {
        return await this.publishCarousel(data, accessToken, accountId);
      }

    } catch (error: any) {
      console.error('üî¥ Instagram Publisher Error:', error);
      const publishResult: PublishResult = {
        success: false,
        error: `Instagram publish error: ${error.message}`
      };
      this.logPublishAttempt(data, publishResult);
      return publishResult;
    }
  }

  /**
   * Publish single media post
   */
  private async publishSingleMedia(data: PublishData, accessToken: string, accountId: string): Promise<PublishResult> {
    try {
      console.log('üì∑ Publishing single media to Instagram...');

      // Step 1: Create media container
      const mediaData: any = {
        image_url: data.mediaUrls[0],
        caption: data.content,
        access_token: accessToken
      };

      // Detect if it's a video (basic check)
      const isVideo = this.isVideoUrl(data.mediaUrls[0]);
      if (isVideo) {
        mediaData.media_type = 'VIDEO';
        delete mediaData.image_url;
        mediaData.video_url = data.mediaUrls[0];
      }

      const mediaResponse = await fetch(`https://graph.facebook.com/v18.0/${accountId}/media`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(mediaData)
      });

      const mediaResult = await mediaResponse.json();
      
      if (!mediaResponse.ok || !mediaResult.id) {
        const publishResult: PublishResult = {
          success: false,
          error: this.getInstagramErrorMessage(mediaResult),
          platformResponse: mediaResult
        };
        this.logPublishAttempt(data, publishResult);
        return publishResult;
      }

      console.log('‚úÖ Media container created:', mediaResult.id);

      // Step 2: Wait for media processing (for videos)
      if (isVideo) {
        await this.waitForMediaProcessing(mediaResult.id, accessToken);
      }

      // Step 3: Publish the media
      const publishResponse = await fetch(`https://graph.facebook.com/v18.0/${accountId}/media_publish`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          creation_id: mediaResult.id,
          access_token: accessToken
        })
      });

      const publishResult = await publishResponse.json();

      if (publishResponse.ok && publishResult.id) {
        const result: PublishResult = {
          success: true,
          externalPostId: publishResult.id,
          platformResponse: publishResult,
          metadata: {
            mediaType: isVideo ? 'video' : 'image',
            mediaContainerId: mediaResult.id
          }
        };
        this.logPublishAttempt(data, result);
        return result;
      } else {
        const result: PublishResult = {
          success: false,
          error: this.getInstagramErrorMessage(publishResult),
          platformResponse: publishResult
        };
        this.logPublishAttempt(data, result);
        return result;
      }

    } catch (error: any) {
      const publishResult: PublishResult = {
        success: false,
        error: `Instagram single media error: ${error.message}`
      };
      this.logPublishAttempt(data, publishResult);
      return publishResult;
    }
  }

  /**
   * Publish carousel post (multiple media)
   */
  private async publishCarousel(data: PublishData, accessToken: string, accountId: string): Promise<PublishResult> {
    try {
      console.log('üé† Publishing carousel to Instagram...');

      // Step 1: Create media containers for each item
      const mediaContainerIds: string[] = [];

      for (const [index, mediaUrl] of data.mediaUrls.entries()) {
        const isVideo = this.isVideoUrl(mediaUrl);
        const mediaData: any = {
          is_carousel_item: true,
          access_token: accessToken
        };

        if (isVideo) {
          mediaData.media_type = 'VIDEO';
          mediaData.video_url = mediaUrl;
        } else {
          mediaData.image_url = mediaUrl;
        }

        const response = await fetch(`https://graph.facebook.com/v18.0/${accountId}/media`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(mediaData)
        });

        const result = await response.json();
        
        if (response.ok && result.id) {
          mediaContainerIds.push(result.id);
          console.log(`‚úÖ Carousel item ${index + 1} created:`, result.id);
          
          // Wait for video processing
          if (isVideo) {
            await this.waitForMediaProcessing(result.id, accessToken);
          }
        } else {
          console.error(`‚ùå Failed to create carousel item ${index + 1}:`, result);
        }
      }

      if (mediaContainerIds.length === 0) {
        return {
          success: false,
          error: 'Failed to create any media containers for carousel'
        };
      }

      // Step 2: Create carousel container
      const carouselResponse = await fetch(`https://graph.facebook.com/v18.0/${accountId}/media`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          media_type: 'CAROUSEL',
          children: mediaContainerIds.join(','),
          caption: data.content,
          access_token: accessToken
        })
      });

      const carouselResult = await carouselResponse.json();

      if (!carouselResponse.ok || !carouselResult.id) {
        return {
          success: false,
          error: this.getInstagramErrorMessage(carouselResult),
          platformResponse: carouselResult
        };
      }

      console.log('üé† Carousel container created:', carouselResult.id);

      // Step 3: Publish the carousel
      const publishResponse = await fetch(`https://graph.facebook.com/v18.0/${accountId}/media_publish`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          creation_id: carouselResult.id,
          access_token: accessToken
        })
      });

      const publishResult = await publishResponse.json();

      if (publishResponse.ok && publishResult.id) {
        const result: PublishResult = {
          success: true,
          externalPostId: publishResult.id,
          platformResponse: publishResult,
          metadata: {
            mediaType: 'carousel',
            carouselContainerId: carouselResult.id,
            mediaContainerIds: mediaContainerIds,
            itemCount: mediaContainerIds.length
          }
        };
        this.logPublishAttempt(data, result);
        return result;
      } else {
        const result: PublishResult = {
          success: false,
          error: this.getInstagramErrorMessage(publishResult),
          platformResponse: publishResult
        };
        this.logPublishAttempt(data, result);
        return result;
      }

    } catch (error: any) {
      const publishResult: PublishResult = {
        success: false,
        error: `Instagram carousel error: ${error.message}`
      };
      this.logPublishAttempt(data, publishResult);
      return publishResult;
    }
  }

  /**
   * Wait for media processing to complete (especially for videos)
   */
  private async waitForMediaProcessing(mediaId: string, accessToken: string): Promise<void> {
    const maxAttempts = 10;
    const delay = 2000; // 2 seconds

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = await fetch(`https://graph.facebook.com/v18.0/${mediaId}?fields=status_code&access_token=${accessToken}`);
        const result = await response.json();

        if (result.status_code === 'FINISHED') {
          console.log('‚úÖ Media processing completed');
          return;
        } else if (result.status_code === 'ERROR') {
          throw new Error('Media processing failed');
        }

        console.log(`‚è≥ Media processing... (${attempt + 1}/${maxAttempts})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } catch (error) {
        console.error('Error checking media status:', error);
        break;
      }
    }
  }

  /**
   * Check if URL is a video based on file extension
   */
  private isVideoUrl(url: string): boolean {
    const videoExtensions = ['.mp4', '.mov', '.avi', '.wmv', '.flv', '.webm', '.mkv'];
    const urlLower = url.toLowerCase();
    return videoExtensions.some(ext => urlLower.includes(ext));
  }

  /**
   * Parse Instagram API error messages
   */
  private getInstagramErrorMessage(result: any): string {
    if (result.error) {
      const { message, code, error_user_title, error_user_msg } = result.error;
      
      // Common Instagram error codes
      switch (code) {
        case 190:
          return 'Token Instagram ƒë√£ h·∫øt h·∫°n. Vui l√≤ng k·∫øt n·ªëi l·∫°i t√†i kho·∫£n.';
        case 100:
          return 'Th√¥ng s·ªë kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i n·ªôi dung v√† h√¨nh ·∫£nh.';
        case 9007:
          return 'T√†i kho·∫£n Instagram kh√¥ng c√≥ quy·ªÅn ƒëƒÉng b√†i. C·∫ßn chuy·ªÉn sang Business/Creator account.';
        case 9004:
          return 'N·ªôi dung ho·∫∑c h√¨nh ·∫£nh vi ph·∫°m ch√≠nh s√°ch c·ªßa Instagram.';
        case 36000:
          return 'ƒê√£ ƒë·∫°t gi·ªõi h·∫°n s·ªë l∆∞·ª£ng b√†i ƒëƒÉng trong ng√†y.';
        default:
          return error_user_msg || message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ Instagram API.';
      }
    }
    
    return 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi ƒëƒÉng b√†i l√™n Instagram.';
  }
}

/**
 * Zalo Publisher
 */
export class ZaloPublisher extends BaseSocialPublisher {
  protected decryptToken(encryptedToken: string): string {
    return OAuthTokenManager.decryptForUse(encryptedToken);
  }

  async publish(data: PublishData): Promise<PublishResult> {
    try {
      const accessToken = this.decryptToken(this.account.token_encrypted);
      const oaId = this.account.provider_id;

      console.log('üì± Zalo Publisher - Starting publish process:', {
        oaId,
        hasMedia: data.mediaUrls && data.mediaUrls.length > 0,
        isScheduled: !!data.scheduledAt
      });

      // Zalo OA supports different message types
      let messageData: any;

      if (data.mediaUrls && data.mediaUrls.length > 0) {
        // Media message
        if (data.mediaUrls.length === 1) {
          messageData = await this.createSingleMediaMessage(data, accessToken, oaId);
        } else {
          messageData = await this.createCarouselMessage(data, accessToken, oaId);
        }
      } else {
        // Text only message
        messageData = {
          recipient: {
            user_id: "broadcast" // For OA broadcast
          },
          message: {
            text: data.content
          }
        };
      }

      // Handle scheduled posting (if supported by Zalo)
      if (data.scheduledAt) {
        console.log('‚ö†Ô∏è Zalo scheduled posting not fully supported, publishing immediately');
      }

      // Send message via Zalo OA API
      const response = await fetch(`https://openapi.zalo.me/v3.0/oa/message/cs`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'access_token': accessToken
        },
        body: JSON.stringify(messageData)
      });

      const result = await response.json();

      console.log('üì° Zalo API Response:', {
        status: response.status,
        success: response.ok && result.error === 0,
        data: result
      });

      if (response.ok && result.error === 0) {
        const publishResult: PublishResult = {
          success: true,
          externalPostId: result.data?.message_id || `zalo_${Date.now()}`,
          platformResponse: result,
          metadata: {
            messageType: data.mediaUrls?.length > 0 ? 'media' : 'text',
            oaId: oaId
          }
        };
        this.logPublishAttempt(data, publishResult);
        return publishResult;
      } else {
        const publishResult: PublishResult = {
          success: false,
          error: this.getZaloErrorMessage(result),
          platformResponse: result
        };
        this.logPublishAttempt(data, publishResult);
        return publishResult;
      }

    } catch (error: any) {
      console.error('üî¥ Zalo Publisher Error:', error);
      const publishResult: PublishResult = {
        success: false,
        error: `Zalo publish error: ${error.message}`
      };
      this.logPublishAttempt(data, publishResult);
      return publishResult;
    }
  }

  /**
   * Create single media message for Zalo
   */
  private async createSingleMediaMessage(data: PublishData, accessToken: string, oaId: string): Promise<any> {
    const mediaUrl = data.mediaUrls[0];
    const isImage = this.isImageUrl(mediaUrl);

    if (isImage) {
      return {
        recipient: {
          user_id: "broadcast"
        },
        message: {
          attachment: {
            type: "image",
            payload: {
              url: mediaUrl,
              caption: data.content
            }
          }
        }
      };
    } else {
      // For files or other media types
      return {
        recipient: {
          user_id: "broadcast"
        },
        message: {
          attachment: {
            type: "file",
            payload: {
              url: mediaUrl
            }
          },
          text: data.content
        }
      };
    }
  }

  /**
   * Create carousel/gallery message for Zalo
   */
  private async createCarouselMessage(data: PublishData, accessToken: string, oaId: string): Promise<any> {
    return {
      recipient: {
        user_id: "broadcast"
      },
      message: {
        attachment: {
          type: "template",
          payload: {
            template_type: "list",
            elements: data.mediaUrls.slice(0, 4).map((url, index) => ({
              title: `H√¨nh ${index + 1}`,
              image_url: url,
              subtitle: index === 0 ? data.content : ""
            }))
          }
        }
      }
    };
  }

  /**
   * Check if URL is an image
   */
  private isImageUrl(url: string): boolean {
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
    const urlLower = url.toLowerCase();
    return imageExtensions.some(ext => urlLower.includes(ext));
  }

  /**
   * Parse Zalo API error messages
   */
  private getZaloErrorMessage(result: any): string {
    if (result.error && result.error !== 0) {
      const errorCode = result.error;
      const message = result.message;

      // Common Zalo error codes
      switch (errorCode) {
        case -124:
          return 'Token Zalo ƒë√£ h·∫øt h·∫°n. Vui l√≤ng k·∫øt n·ªëi l·∫°i t√†i kho·∫£n.';
        case -201:
          return 'OA ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát ho·∫∑c b·ªã kh√≥a.';
        case -213:
          return 'Kh√¥ng c√≥ quy·ªÅn g·ª≠i tin nh·∫Øn t·ªõi ng∆∞·ªùi d√πng n√†y.';
        case -214:
          return 'N·ªôi dung tin nh·∫Øn vi ph·∫°m ch√≠nh s√°ch c·ªßa Zalo.';
        case -216:
          return 'ƒê√£ ƒë·∫°t gi·ªõi h·∫°n s·ªë l∆∞·ª£ng tin nh·∫Øn trong ng√†y.';
        case -232:
          return 'File ƒë√≠nh k√®m kh√¥ng h·ª£p l·ªá ho·∫∑c qu√° l·ªõn.';
        default:
          return message || `L·ªói Zalo API: ${errorCode}`;
      }
    }
    
    return 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i tin nh·∫Øn Zalo.';
  }
}

/**
 * Factory function ƒë·ªÉ t·∫°o publisher theo provider
 */
export function createPublisher(account: SocialAccount): BaseSocialPublisher {
  switch (account.provider) {
    case 'facebook':
      return new FacebookPublisher(account);
    case 'instagram':
      return new InstagramPublisher(account);
    case 'zalo':
      return new ZaloPublisher(account);
    default:
      throw new Error(`Unsupported provider: ${account.provider}`);
  }
}

/**
 * Log publish activity
 */
export async function logPublishActivity(
  postId: string,
  scheduleId: string,
  account: SocialAccount,
  result: PublishResult,
  userId?: string
) {
  const sb = sbServer(true);
  
  const status = result.success ? 'success' : 'failed';
  const description = result.success 
    ? `ƒêƒÉng b√†i th√†nh c√¥ng l√™n ${account.provider}: ${account.name}`
    : `ƒêƒÉng b√†i th·∫•t b·∫°i l√™n ${account.provider}: ${account.name} - ${result.error}`;

  try {
    await sb.from('autopostvn_system_activity_logs').insert({
      user_id: userId,
      action_type: 'post_published',
      action_category: 'post',
      description,
      status,
      target_resource_type: 'post',
      target_resource_id: postId,
      additional_data: {
        schedule_id: scheduleId,
        social_account_id: account.id,
        provider: account.provider,
        external_post_id: result.externalPostId,
        error: result.error,
        platform_response: result.platformResponse,
        publish_timestamp: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Failed to log publish activity:', error);
  }
}
